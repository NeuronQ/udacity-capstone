- stage 1 - POC runs
  - bs@5ms simple [done]
  - bc@5m multi-feature [done]
  - bc@5m - day of week
  - bc@24h -simple
    - improve seq_len
  - bc@24h multi feature
  - bc@24m trend derived from sp500
    - decide on measures
    - implement
  - bs trend in bc related comps
- stage 2 - full runs
- stage 3 - text v1
- stage 4 - proofread text and correct to match full runs



###############################################################



- stage A: models and data
  - phase 1: bc simple
    - clean up code
    - general structure refactor sketch
  - phase 2: bc multi-feature basic
    - try with all features and figure out training times
      and good numbers for training epochs
    - figure out a way to "interpolate" secondary features
  - phase 3: switch to bc24h data
  - phase 3: derived feature from sp500
    - pick a good derived feature
    - run with it


###############################################

0
- 1: sort out measures
  - [X] look up direction prediction accuracy definition
    - https://en.wikipedia.org/wiki/Mean_Directional_Accuracy
    - SCP (sign correctness proportion)
  - [X] review DACC code
  - update code to predict at every point
  - add alternative to prediction probability of upward movement instead
- 2: test runs for simple bc pred on first/mid/last 10%s
- 3: re-review prediction goals theory
- 4: plan correlated models

N: 10, seq_len: 4, pred_len: 3
0 1 2 3 4 5 6 7 9
0 1 2 3 - - -
  1 2 3 4 - - -
    2 3 4 5 - - -
    (stop at 2 = N:10 - seq_len:4 - pred_len:3 - 1)

100 75 75 75
100..175 0 y_start=99 y_target=174
101..176 1 y_start=100, y_target=175
102..177 2


0: 0..100 -- need 175-1 and 100-1
1: 1..101
...
0+75: 0+75..100+75
...
i: i..(i+100)


100:175
175:250

100:175
101:176250250250

sameple

# N: 10, seq_len: 5, pred_len: 3, batch_sz: 4
0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18

_batch_1______________
0 1 2 3 4 - - -
  1 2 3 4 5 - - -
    2 3 4 5 6 - - -
      3 4 5 6 7 - - --

        _batch_2__________________
        4 5 6 7 8 - -- --
          5 6 7 8 9 -- -- --
            6 7 8 9 10 -- -- --
              7 8 9 10 11 -- -- --

              _batch_3_____________________
              7 8 9 10 11 -- -- --
                8 9 10 11 12 -- -- --
                  9 10 11 12 13 -- -- --
                    10 11 12 13 14 -- -- --
                    
                       _batch_4_(incomplete)__
                       11 12 13 14 15 -- -- --

                    (stop at 10 = 19 - 5 - 3 - 1)

0 1 2 3 4 5 6 7 9
0 1 2 3 4 - - -
  1 2 3 4 5 - - -

0 1 2 3 4 5 6 7 8 9
0 1 2 3 4 - - -
  1 2 3 4 5 - - -
    2 3 4 5 6 - - -



##################
**Goal:** find a `MinProfitableAccAvg(#ahead)` function.

For:
* `Acc = 0.5 + eps`

...amount gained can be computed by noting that:
* `0.5 + eps` of the time we predict correctly
* `0.5 - eps` of the time me predict incorrectly
* when we predict correctly  win on average `std(#ahead)` (times traded quantity but we can take it to be 1 here)

...so on average we gain:
* `(0.5 + eps) * std - (0.5 - eps) * std = 2 * eps * std`

To make a profit we must gain more than the costs of operating the strategy, which are made up of (times qty, but it's 1):
* a % transction fee: `fee`
* the bid-ask spread: `spread`

So our profit function looks like this:
* `Profit(#ahead, eps) = 2 * eps * std(#ahead) - fee - spread`

So our function needs to find for each `#ahead` the minimump `eps` (searching up to a max) for which `Profit` is 0 (and the accuracy is 0.5 plus that eps ofc).

Ergo:
* `MinProfitableAcc(#ahead) = (fee+spread) / 2*std(#ahead) + 0.5`